<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vanilla JS Transformer Demo + GGUF Loader</title>
    <style>
        body { font-family: monospace; background: #232323; color: #ddd; padding: 24px; }
        .output { margin-top: 24px; font-size: 1.1em; }
        .btn { background: #444; color: #fff; border: none; padding: 8px 16px; cursor: pointer; margin-top: 12px;}
        .btn:hover { background: #666; }
        input[type="number"] { width: 60px; }
        .fileUpload { margin: 18px 0 8px 0; }
    </style>
</head>
<body>
<h1>JavaScript Transformer (Vanilla, in-browser) + GGUF Loader</h1>
<div>
    <label>Sequence length: <input type="number" id="seqLen" value="10" min="1" max="64"></label><br>
    <label>Embedding dimension: <input type="number" id="embedDim" value="16" min="4" max="128"></label><br>
    <label>Num heads: <input type="number" id="numHeads" value="2" min="1" max="8"></label><br>
    <label>Blocks: <input type="number" id="numBlocks" value="2" min="1" max="8"></label><br>
    <label>Hidden (FFN) dim: <input type="number" id="ffnHidden" value="32" min="4" max="256"></label><br>
    <label>Classes: <input type="number" id="numClasses" value="3" min="1" max="10"></label>
</div>
<button class="btn" onclick="runTransformer()">Run Transformer Prediction</button>
<div class="output" id="output"></div>
<div class="fileUpload">
    <label style="font-weight:bold">
        GGUF Model File:
        <input type="file" id="ggufFileInput" accept=".gguf">
    </label>
    <button id="loadGgufBtn" class="btn" style="margin-left:10px">Load GGUF into Transformer</button>
    <span id="ggufStatus" style="margin-left:14px; color:#bffcff"></span>
</div>

<script>
let loadedWeights = null;

// === Helper Math Functions ===
function zeros(rows, cols) {
    return Array(rows).fill(0).map(() => Array(cols).fill(0));
}
function randn(rows, cols, scale=0.1) {
    return Array(rows).fill(0).map(() => Array(cols).fill(0).map(() => (Math.random() - 0.5) * 2 * scale));
}
function softmax(arr) {
    const max = Math.max(...arr);
    const exps = arr.map(x => Math.exp(x - max));
    const sum = exps.reduce((a, b) => a + b, 0);
    return exps.map(x => x / sum);
}
function relu(x) { return Math.max(0, x); }
function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
function mean(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
function stdev(arr) {
    const m = mean(arr);
    return Math.sqrt(mean(arr.map(x => (x - m) ** 2)) + 1e-6);
}
function clone2D(arr) {
    return arr.map(row => row.slice());
}

// === Transformer Classes ===
class AttentionHead {
    constructor(embedDim, headDim) {
        this.embedDim = embedDim;
        this.headDim = headDim;
        this.QueryWeights = randn(embedDim, headDim, Math.sqrt(2/embedDim));
        this.KeyWeights   = randn(embedDim, headDim, Math.sqrt(2/embedDim));
        this.ValueWeights = randn(embedDim, headDim, Math.sqrt(2/embedDim));
        this.QueryBias = Array(headDim).fill(0);
        this.KeyBias   = Array(headDim).fill(0);
        this.ValueBias = Array(headDim).fill(0);
    }
    forward(input) {
        const seqLen = input.length;
        let Q = zeros(seqLen, this.headDim), K = zeros(seqLen, this.headDim), V = zeros(seqLen, this.headDim);
        for (let i = 0; i < seqLen; ++i) {
            for (let j = 0; j < this.headDim; ++j) {
                Q[i][j] = this.QueryBias[j];
                K[i][j] = this.KeyBias[j];
                V[i][j] = this.ValueBias[j];
                for (let k = 0; k < this.embedDim; ++k) {
                    Q[i][j] += input[i][k] * this.QueryWeights[k][j];
                    K[i][j] += input[i][k] * this.KeyWeights[k][j];
                    V[i][j] += input[i][k] * this.ValueWeights[k][j];
                }
            }
        }
        let scores = zeros(seqLen, seqLen);
        const scale = Math.sqrt(this.headDim);
        for (let i = 0; i < seqLen; ++i) {
            for (let j = 0; j < seqLen; ++j) {
                let s = 0;
                for (let d = 0; d < this.headDim; ++d)
                    s += Q[i][d] * K[j][d];
                scores[i][j] = s / scale;
            }
            let sm = softmax(scores[i]);
            for (let j = 0; j < seqLen; ++j) scores[i][j] = sm[j];
        }
        let out = zeros(seqLen, this.headDim);
        for (let i = 0; i < seqLen; ++i) {
            for (let d = 0; d < this.headDim; ++d) {
                let s = 0;
                for (let k = 0; k < seqLen; ++k)
                    s += scores[i][k] * V[k][d];
                out[i][d] = s;
            }
        }
        return out;
    }
}
class MultiHeadAttention {
    constructor(embedDim, numHeads) {
        this.embedDim = embedDim;
        this.numHeads = numHeads;
        this.headDim = Math.floor(embedDim / numHeads);
        this.heads = [];
        for (let i = 0; i < numHeads; ++i)
            this.heads.push(new AttentionHead(embedDim, this.headDim));
        this.OutputWeights = randn(numHeads * this.headDim, embedDim, Math.sqrt(2/(numHeads*this.headDim)));
        this.OutputBias = Array(embedDim).fill(0);
    }
    forward(input) {
        const seqLen = input.length;
        let concat = zeros(seqLen, this.numHeads * this.headDim);
        for (let h = 0; h < this.numHeads; ++h) {
            let headOut = this.heads[h].forward(input);
            for (let i = 0; i < seqLen; ++i)
                for (let d = 0; d < this.headDim; ++d)
                    concat[i][h * this.headDim + d] = headOut[i][d];
        }
        let out = zeros(seqLen, this.embedDim);
        for (let i = 0; i < seqLen; ++i) {
            for (let j = 0; j < this.embedDim; ++j) {
                let s = this.OutputBias[j];
                for (let k = 0; k < this.numHeads * this.headDim; ++k)
                    s += concat[i][k] * this.OutputWeights[k][j];
                out[i][j] = s;
            }
        }
        return out;
    }
}
class FeedForwardNetwork {
    constructor(embedDim, hiddenDim) {
        this.layer1Weights = randn(embedDim, hiddenDim, Math.sqrt(2/embedDim));
        this.layer1Bias = Array(hiddenDim).fill(0);
        this.layer2Weights = randn(hiddenDim, embedDim, Math.sqrt(2/hiddenDim));
        this.layer2Bias = Array(embedDim).fill(0);
    }
    forward(input) {
        const seqLen = input.length;
        let hidden = zeros(seqLen, this.layer1Bias.length);
        for (let i = 0; i < seqLen; ++i) {
            for (let h = 0; h < this.layer1Bias.length; ++h) {
                let s = this.layer1Bias[h];
                for (let k = 0; k < input[i].length; ++k)
                    s += input[i][k] * this.layer1Weights[k][h];
                hidden[i][h] = relu(s);
            }
        }
        let out = zeros(seqLen, this.layer2Bias.length);
        for (let i = 0; i < seqLen; ++i) {
            for (let e = 0; e < this.layer2Bias.length; ++e) {
                let s = this.layer2Bias[e];
                for (let h = 0; h < hidden[i].length; ++h)
                    s += hidden[i][h] * this.layer2Weights[h][e];
                out[i][e] = s;
            }
        }
        return out;
    }
}
class LayerNorm {
    constructor(embedDim) {
        this.gamma = Array(embedDim).fill(1.0);
        this.beta  = Array(embedDim).fill(0.0);
    }
    forward(input) {
        const seqLen = input.length;
        const embedDim = input[0].length;
        let out = zeros(seqLen, embedDim);
        for (let i = 0; i < seqLen; ++i) {
            const row = input[i];
            const m = mean(row);
            const sd = stdev(row);
            for (let j = 0; j < embedDim; ++j)
                out[i][j] = this.gamma[j] * ((row[j] - m) / sd) + this.beta[j];
        }
        return out;
    }
}
class TransformerBlock {
    constructor(embedDim, numHeads, ffnHiddenDim) {
        this.attn = new MultiHeadAttention(embedDim, numHeads);
        this.ln1 = new LayerNorm(embedDim);
        this.ffn = new FeedForwardNetwork(embedDim, ffnHiddenDim);
        this.ln2 = new LayerNorm(embedDim);
    }
    forward(input) {
        let attnOut = this.attn.forward(input);
        let res1 = input.map((row, i) => row.map((x, j) => x + attnOut[i][j]));
        let ln1Out = this.ln1.forward(res1);
        let ffnOut = this.ffn.forward(ln1Out);
        let res2 = ln1Out.map((row, i) => row.map((x, j) => x + ffnOut[i][j]));
        let ln2Out = this.ln2.forward(res2);
        return ln2Out;
    }
}
class Transformer {
    constructor(embedDim, numHeads, numBlocks, ffnHiddenDim, maxSeqLen, numClasses) {
        this.embedDim = embedDim;
        this.numHeads = numHeads;
        this.headDim = Math.floor(embedDim / numHeads);
        this.ffnHiddenDim = ffnHiddenDim;
        this.maxSeqLen = maxSeqLen;
        this.numClasses = numClasses;
        this.blocks = [];
        for (let i = 0; i < numBlocks; ++i)
            this.blocks.push(new TransformerBlock(embedDim, numHeads, ffnHiddenDim));
        this.positionalEncoding = this.createPositionalEncoding(maxSeqLen, embedDim);
        this.outWeights = randn(embedDim, numClasses, Math.sqrt(2/embedDim));
        this.outBias = Array(numClasses).fill(0);
    }
    createPositionalEncoding(maxSeqLen, embedDim) {
        let PE = zeros(maxSeqLen, embedDim);
        for (let pos = 0; pos < maxSeqLen; ++pos) {
            for (let i = 0; i < embedDim; ++i) {
                const angle = pos / Math.pow(10000, (2 * Math.floor(i / 2)) / embedDim);
                PE[pos][i] = (i % 2 === 0) ? Math.sin(angle) : Math.cos(angle);
            }
        }
        return PE;
    }
    predict(sequenceTokens) {
        let seqLen = sequenceTokens.length;
        let input = zeros(seqLen, this.embedDim);
        for (let i = 0; i < seqLen; ++i)
            for (let j = 0; j < this.embedDim; ++j)
                input[i][j] = sequenceTokens[i][j] + this.positionalEncoding[i][j];
        for (let blk of this.blocks)
            input = blk.forward(input);
        let pooled = Array(this.embedDim).fill(0);
        for (let j = 0; j < this.embedDim; ++j) {
            let s = 0;
            for (let i = 0; i < seqLen; ++i)
                s += input[i][j];
            pooled[j] = s / seqLen;
        }
        let out = Array(this.numClasses).fill(0);
        for (let c = 0; c < this.numClasses; ++c) {
            let s = this.outBias[c];
            for (let j = 0; j < this.embedDim; ++j)
                s += pooled[j] * this.outWeights[j][c];
            out[c] = sigmoid(s);
        }
        return out;
    }
}

// === GGUF Loader logic with bounds checking ===
function readUint32(view, offset) {
    if (offset + 4 > view.byteLength) throw new Error("readUint32: offset out of bounds");
    return view.getUint32(offset, true);
}
function readUint64(view, offset) {
    if (offset + 8 > view.byteLength) throw new Error("readUint64: offset out of bounds");
    const low = view.getUint32(offset, true);
    const high = view.getUint32(offset + 4, true);
    return low + high * 0x100000000;
}
function readStringSafe(view, offset) {
    if (offset + 8 > view.byteLength) {
        return { string: "<incomplete string header>", nextOffset: view.byteLength, truncated: true };
    }
    let strLen;
    try { strLen = readUint64(view, offset); } catch (e) {
        return { string: `<error: ${e.message}>`, nextOffset: view.byteLength, truncated: true };
    }
    const stringOffset = offset + 8;
    if (stringOffset + strLen > view.byteLength) {
        return {
            string: `<string truncated (${strLen} bytes, got only ${view.byteLength - stringOffset})>`,
            nextOffset: view.byteLength,
            truncated: true
        };
    }
    const bytes = new Uint8Array(view.buffer, stringOffset, strLen);
    const string = new TextDecoder().decode(bytes);
    return { string, nextOffset: stringOffset + strLen, truncated: false };
}
const GGUF_TYPE = {
    UINT8: 0,  INT8: 1, UINT16: 2, INT16: 3,
    UINT32: 4, INT32: 5, FLOAT32: 6, BOOL: 7,
    STRING: 8, ARRAY: 9, UINT64: 10, INT64: 11, FLOAT64: 12
};
function readMetadataValue(view, offset, type) {
    let value, nextOffset = offset;
    const checkBounds = needed => {
        if (offset + needed > view.byteLength)
            throw new Error(`Not enough data (need ${needed} bytes at offset ${offset}, has ${view.byteLength - offset})`);
    };
    try {
        switch(type) {
        case GGUF_TYPE.UINT8:
            checkBounds(1);
            value = view.getUint8(offset);
            nextOffset = offset + 1; break;
        case GGUF_TYPE.INT8:
            checkBounds(1);
            value = view.getInt8(offset);
            nextOffset = offset + 1; break;
        case GGUF_TYPE.UINT16:
            checkBounds(2);
            value = view.getUint16(offset, true);
            nextOffset = offset + 2; break;
        case GGUF_TYPE.INT16:
            checkBounds(2);
            value = view.getInt16(offset, true);
            nextOffset = offset + 2; break;
        case GGUF_TYPE.UINT32:
            checkBounds(4);
            value = readUint32(view, offset);
            nextOffset = offset + 4; break;
        case GGUF_TYPE.INT32:
            checkBounds(4);
            value = view.getInt32(offset, true);
            nextOffset = offset + 4; break;
        case GGUF_TYPE.FLOAT32:
            checkBounds(4);
            value = view.getFloat32(offset, true);
            nextOffset = offset + 4; break;
        case GGUF_TYPE.BOOL:
            checkBounds(1);
            value = view.getUint8(offset) !== 0;
            nextOffset = offset + 1; break;
        case GGUF_TYPE.STRING: {
            const result = readStringSafe(view, offset);
            value = result.string;
            nextOffset = result.nextOffset;
            break;
        }
        case GGUF_TYPE.UINT64:
            checkBounds(8);
            value = readUint64(view, offset);
            nextOffset = offset + 8; break;
        case GGUF_TYPE.ARRAY:
            checkBounds(12);
            const arrayType = readUint32(view, offset);
            const arrayCount = readUint64(view, offset + 4);
            value = `[type ${arrayType} x ${arrayCount}]`;
            nextOffset = offset + 12 + arrayCount * 4;
            break;
        default:
            value = 'UNSUPPORTED';
            nextOffset = offset;
        }
    } catch(e) {
        value = `<error: ${e.message}>`;
        nextOffset = view.byteLength;
    }
    return { value, nextOffset };
}
function toNestedArray1D(flat, rows, cols) {
    let out = [];
    for (let r = 0; r < rows; ++r) {
        out.push(Array.from(flat.slice(r*cols, (r+1)*cols)));
    }
    return out;
}

// --- GGUF loader: demo output weights mapping ---
function parseAndLoadGguf(buffer, embedDim, numClasses) {
    let view = new DataView(buffer);
    let offset = 0;
    try {
        // skip magic/version, and get counts (with bounds checks)
        offset += 4; // "GGUF"
        offset += 4; // version
        const tensorCount = readUint64(view, offset); offset += 8;
        const metadataCount = readUint64(view, offset); offset += 8;

        // --- Parse metadata table robustly! ---
        for (let i = 0; i < metadataCount; ++i) {
            const { string: key, nextOffset: afterKey } = readStringSafe(view, offset);
            offset = afterKey;
            if (offset + 4 > view.byteLength) throw new Error("Metadata value type OOB");
            const valueType = readUint32(view, offset); offset += 4;
            const { value, nextOffset: afterValue } = readMetadataValue(view, offset, valueType);
            offset = afterValue;
        }

        // =========== Parse Tensors ===========
        let foundTensor = false;
        for (let i = 0; i < tensorCount; ++i) {
            const { string: name, nextOffset: afterName } = readStringSafe(view, offset);
            offset = afterName;

            if (offset + 4*2 > view.byteLength)
                throw new Error(`Tensor header OOB @ ${offset}`);
            let dtype = readUint32(view, offset); offset += 4;
            let n_dims = readUint32(view, offset); offset += 4;

            let shape = [];
            for (let d = 0; d < n_dims; ++d) {
                shape.push(readUint64(view, offset)); offset += 8;
            }
            let dataOffset = readUint64(view, offset); offset += 8;
            let dataLen = readUint64(view, offset); offset += 8;
            // dtype 6: float32
            // For demo: look for output weights
            if (
                !foundTensor &&
                dtype === 6 &&
                shape.length === 2 &&
                ((shape[0] === embedDim && shape[1] === numClasses) ||
                 (shape[1] === embedDim && shape[0] === numClasses))
            ) {
                if (dataOffset + dataLen > view.byteLength)
                    throw new Error("Tensor data OOB");
                const arr = new Float32Array(buffer, dataOffset, dataLen/4);
                let outArray;
                if (shape[0] === embedDim && shape[1] === numClasses)
                    outArray = toNestedArray1D(arr, embedDim, numClasses);
                else
                    // transpose [numClasses, embedDim]
                    outArray = [];
                    for (let col = 0; col < embedDim; ++col) {
                        outArray.push([]);
                        for (let row = 0; row < numClasses; ++row) {
                            outArray[col].push(arr[row * embedDim + col]);
                        }
                    }
                loadedWeights = { outWeights: outArray };
                foundTensor = true;
                document.getElementById('ggufStatus').textContent = "Loaded tensor: " + name;
                break;
            }
        }
        if (!foundTensor) {
            loadedWeights = null;
            document.getElementById('ggufStatus').textContent = "No matching [embed,numClasses] float32 weight tensor found.";
        }
    } catch (err) {
        loadedWeights = null;
        document.getElementById('ggufStatus').textContent = "Error: " + err.message;
    }
}

document.getElementById('loadGgufBtn').onclick = function() {
    const file = document.getElementById('ggufFileInput').files[0];
    if (!file) {
        document.getElementById('ggufStatus').textContent = "No file selected!";
        return;
    }
    const embedDim = parseInt(document.getElementById('embedDim').value);
    const numClasses = parseInt(document.getElementById('numClasses').value);
    document.getElementById('ggufStatus').textContent = "Reading file...";
    file.arrayBuffer().then(buf => {
        parseAndLoadGguf(buf, embedDim, numClasses);
    });
};

// -- Patch Transformer Runner to inject GGUF weights if loaded --
function runTransformer() {
    const seqLen = parseInt(document.getElementById('seqLen').value);
    const embedDim = parseInt(document.getElementById('embedDim').value);
    const numHeads = parseInt(document.getElementById('numHeads').value);
    const numBlocks = parseInt(document.getElementById('numBlocks').value);
    const ffnHidden = parseInt(document.getElementById('ffnHidden').value);
    const numClasses = parseInt(document.getElementById('numClasses').value);

    let seqTokens = [];
    for (let i = 0; i < seqLen; ++i) {
        seqTokens.push(Array(embedDim).fill(0).map(() => Math.random()));
    }
    let transformer = new Transformer(embedDim, numHeads, numBlocks, ffnHidden, Math.max(seqLen, 50), numClasses);

    if (loadedWeights && loadedWeights.outWeights) {
        transformer.outWeights = loadedWeights.outWeights;
        document.getElementById('ggufStatus').textContent += " | Weights injected!";
    }
    const prediction = transformer.predict(seqTokens);
    document.getElementById('output').innerHTML =
        `<b>Input Sequence:</b> [${seqLen} x ${embedDim} random tensor]<br>
         <b>Prediction:</b> [${prediction.map(x => x.toFixed(4)).join(', ')}]`;
}
</script>
</body>
</html>
